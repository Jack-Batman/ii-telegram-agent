"""\nReminder Manager - Quick reminders with natural language support.\n\nProvides a simple interface for setting reminders that integrates\nwith the main scheduler.\n"""\n\nimport json\nimport logging\nimport re\nfrom datetime import datetime, timedelta\nfrom pathlib import Path\nfrom typing import Optional\n\nlogger = logging.getLogger(__name__)\n\n\nclass ReminderManager:\n    """\n    Manages quick reminders with natural language time parsing.\n    \n    Examples:\n    - "remind me in 30 minutes to call John"\n    - "remind me tomorrow at 9am about the meeting"\n    - "remind me in 2 hours to check the oven"\n    """\n\n    def __init__(self, workspace_dir: Optional[str] = None):\n        self.workspace_dir = Path(workspace_dir or "~/.ii-telegram-agent/workspace").expanduser()\n        self.reminders_file = self.workspace_dir / "reminders.json"\n        self.reminders: list[dict] = []\n        \n        self._load_reminders()\n\n    def _load_reminders(self):\n        """Load reminders from disk."""\n        self.workspace_dir.mkdir(parents=True, exist_ok=True)\n        \n        if self.reminders_file.exists():\n            try:\n                data = json.loads(self.reminders_file.read_text())\n                self.reminders = data.get("reminders", [])\n                self._cleanup_expired()\n            except Exception as e:\n                logger.error(f"Error loading reminders: {e}")\n\n    def _save_reminders(self):\n        """Save reminders to disk."""\n        try:\n            data = {\n                "reminders": self.reminders,\n                "updated_at": datetime.now().isoformat(),\n            }\n            self.reminders_file.write_text(json.dumps(data, indent=2))\n        except Exception as e:\n            logger.error(f"Error saving reminders: {e}")\n\n    def _cleanup_expired(self):\n        """Remove expired reminders that have been delivered."""\n        now = datetime.now()\n        self.reminders = [\n            r for r in self.reminders\n            if not r.get("delivered", False) or \n               datetime.fromisoformat(r["time"]) > now - timedelta(hours=24)\n        ]\n        self._save_reminders()\n\n    def add(\n        self,\n        message: str,\n        time: datetime,\n        recurring: bool = False,\n        recurrence_pattern: Optional[str] = None,\n    ) -> dict:\n        """Add a new reminder."""\n        reminder = {\n            "id": len(self.reminders) + 1,\n            "message": message,\n            "time": time.isoformat(),\n            "created_at": datetime.now().isoformat(),\n            "recurring": recurring,\n            "recurrence_pattern": recurrence_pattern,\n            "delivered": False,\n        }\n        self.reminders.append(reminder)\n        self._save_reminders()\n        \n        logger.info(f"Added reminder: {message} at {time}")\n        return reminder\n\n    def add_from_natural_language(self, text: str) -> Optional[dict]:\n        """\n        Parse natural language and create a reminder.\n        \n        Examples:\n        - "in 30 minutes to call John" -> reminder in 30 min\n        - "tomorrow at 9am about meeting" -> reminder tomorrow 9am\n        - "in 2 hours check oven" -> reminder in 2 hours\n        """\n        time_result = self._parse_time(text)\n        if not time_result:\n            return None\n        \n        parsed_time, remaining_text = time_result\n        message = self._extract_message(remaining_text)\n        \n        if not message:\n            message = remaining_text.strip()\n        \n        return self.add(message, parsed_time)\n\n    def _parse_time(self, text: str) -> Optional[tuple[datetime, str]]:\n        """Parse time from natural language text."""\n        text = text.lower().strip()\n        now = datetime.now()\n        \n        patterns = [\n            (r"in (\d+)\s*(?:min(?:ute)?s?)", lambda m: (now + timedelta(minutes=int(m.group(1))), m)),\n            (r"in (\d+)\s*(?:hour?s?|hr?s?)", lambda m: (now + timedelta(hours=int(m.group(1))), m)),\n            (r"in (\d+)\s*(?:day?s?)", lambda m: (now + timedelta(days=int(m.group(1))), m)),\n            (r"tomorrow\s+(?:at\s+)?(\d{1,2})(?::(\d{2}))?\s*(am|pm)?", self._parse_tomorrow),\n            (r"(?:at\s+)?(\d{1,2})(?::(\d{2}))?\s*(am|pm)", self._parse_today_time),\n            (r"in\s+(\d+)\s+and\s+(?:a\s+)?half\s+hours?", lambda m: (now + timedelta(hours=int(m.group(1)) + 0.5), m)),\n        ]\n        \n        for pattern, handler in patterns:\n            match = re.search(pattern, text)\n            if match:\n                result = handler(match)\n                if result:\n                    time_val, match_obj = result\n                    remaining = text[:match_obj.start()] + text[match_obj.end():]\n                    return time_val, remaining.strip()\n        \n        return None\n\n    def _parse_tomorrow(self, match) -> tuple[datetime, re.Match]:\n        """Parse 'tomorrow at X' expressions."""\n        hour = int(match.group(1))\n        minute = int(match.group(2)) if match.group(2) else 0\n        period = match.group(3)\n        \n        if period == "pm" and hour < 12:\n            hour += 12\n        elif period == "am" and hour == 12:\n            hour = 0\n        \n        tomorrow = datetime.now() + timedelta(days=1)\n        result = tomorrow.replace(hour=hour, minute=minute, second=0, microsecond=0)\n        return result, match\n\n    def _parse_today_time(self, match) -> tuple[datetime, re.Match]:\n        """Parse time expressions for today."""\n        hour = int(match.group(1))\n        minute = int(match.group(2)) if match.group(2) else 0\n        period = match.group(3)\n        \n        if period == "pm" and hour < 12:\n            hour += 12\n        elif period == "am" and hour == 12:\n            hour = 0\n        \n        result = datetime.now().replace(hour=hour, minute=minute, second=0, microsecond=0)\n        \n        if result < datetime.now():\n            result += timedelta(days=1)\n        \n        return result, match\n\n    def _extract_message(self, text: str) -> str:\n        """Extract the reminder message from remaining text."""\n        cleanup_patterns = [\n            r"^(?:to\s+)?",\n            r"^(?:about\s+)?",\n            r"^(?:that\s+)?",\n            r"^(?:remind\s+me\s+)?",\n        ]\n        \n        result = text.strip()\n        for pattern in cleanup_patterns:\n            result = re.sub(pattern, "", result, flags=re.IGNORECASE).strip()\n        \n        return result\n\n    def get_due_reminders(self) -> list[dict]:\n        """Get all reminders that are due."""\n        now = datetime.now()\n        due = []\n        \n        for reminder in self.reminders:\n            if reminder.get("delivered", False):\n                continue\n            \n            reminder_time = datetime.fromisoformat(reminder["time"])\n            if reminder_time <= now:\n                due.append(reminder)\n        \n        return due\n\n    def mark_delivered(self, reminder_id: int):\n        """Mark a reminder as delivered."""\n        for reminder in self.reminders:\n            if reminder["id"] == reminder_id:\n                reminder["delivered"] = True\n                reminder["delivered_at"] = datetime.now().isoformat()\n                self._save_reminders()\n                return True\n        return False\n\n    def list_pending(self) -> list[dict]:\n        """List all pending reminders."""\n        return [r for r in self.reminders if not r.get("delivered", False)]\n\n    def delete(self, reminder_id: int) -> bool:\n        """Delete a reminder."""\n        original_len = len(self.reminders)\n        self.reminders = [r for r in self.reminders if r["id"] != reminder_id]\n        \n        if len(self.reminders) < original_len:\n            self._save_reminders()\n            return True\n        return False\n\n    def format_reminder(self, reminder: dict) -> str:\n        """Format a reminder for display."""\n        time = datetime.fromisoformat(reminder["time"])\n        return f"â° **Reminder**: {reminder['message']}\n*(Set for {time.strftime('%Y-%m-%d %H:%M')})*"\n\n    def get_upcoming_summary(self, hours: int = 24) -> str:\n        """Get a summary of upcoming reminders."""\n        pending = self.list_pending()\n        now = datetime.now()\n        cutoff = now + timedelta(hours=hours)\n        \n        upcoming = [\n            r for r in pending\n            if datetime.fromisoformat(r["time"]) <= cutoff\n        ]\n        \n        if not upcoming:\n            return "No upcoming reminders in the next 24 hours."\n        \n        upcoming.sort(key=lambda r: r["time"])\n        \n        lines = [f"**Upcoming Reminders ({len(upcoming)}):**"]\n        for r in upcoming:\n            time = datetime.fromisoformat(r["time"])\n            time_str = time.strftime("%H:%M" if time.date() == now.date() else "%b %d %H:%M")\n            lines.append(f"- {time_str}: {r['message']}")\n        \n        return "\n".join(lines)