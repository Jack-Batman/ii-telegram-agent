"""\nSkill Writer Tool - Allows the agent to create, save, and manage custom skills.\n\nThis enables self-improvement by letting the agent write new tools based on\nuser needs and its own learning.\n"""\n\nimport os\nimport re\nimport ast\nimport importlib.util\nfrom pathlib import Path\nfrom datetime import datetime\nfrom typing import Any\n\nimport structlog\n\nfrom .base import Tool, ToolParameter, ToolResult\n\nlogger = structlog.get_logger()\n\n# Default skills directory\nDEFAULT_SKILLS_DIR = Path.home() / ".ii-agent" / "skills"\n\n# Template for a new skill\nSKILL_TEMPLATE = '''"""\n{description}\n\nAuto-generated skill by II-Agent\nCreated: {created_at}\n"""\n\nfrom typing import Any\nfrom ii_telegram_agent.tools.base import Tool, ToolParameter, ToolResult\n\n\nasync def {function_name}({parameters_signature}) -> ToolResult:\n    """\n    {description}\n    \n    Args:\n{args_docs}\n    \n    Returns:\n        ToolResult with success status and output\n    """\n    try:\n{implementation}\n        return ToolResult(success=True, output=result)\n    except Exception as e:\n        return ToolResult(success=False, error=str(e))\n\n\ndef create_{skill_name}_tool() -> Tool:\n    """Create the {skill_name} tool."""\n    return Tool(\n        name="{tool_name}",\n        description="""{description}""",\n        parameters=[\n{parameters_list}\n        ],\n        handler={function_name},\n    )\n\n\n# For auto-discovery\nTOOLS = [create_{skill_name}_tool]\n'''\n\n\nclass SkillManager:\n    """Manages custom skills - creation, storage, and loading."""\n    \n    def __init__(self, skills_dir: str | Path | None = None):\n        self.skills_dir = Path(skills_dir) if skills_dir else DEFAULT_SKILLS_DIR\n        self.skills_dir.mkdir(parents=True, exist_ok=True)\n        \n        # Create __init__.py if it doesn't exist\n        init_file = self.skills_dir / "__init__.py"\n        if not init_file.exists():\n            init_file.write_text('"""Custom skills directory for II-Agent."""\n')\n        \n        self._loaded_skills: dict[str, Tool] = {}\n    \n    def _sanitize_name(self, name: str) -> str:\n        """Convert a name to a valid Python identifier."""\n        # Remove special characters, replace spaces with underscores\n        name = re.sub(r'[^\w\s]', '', name)\n        name = re.sub(r'\s+', '_', name)\n        return name.lower()\n    \n    def _validate_code(self, code: str) -> tuple[bool, str]:\n        """Validate Python code for basic safety and syntax."""\n        # Check for dangerous imports/calls\n        dangerous_patterns = [\n            r'\bos\.system\b',\n            r'\bsubprocess\.',\n            r'\beval\s*\(',\n            r'\bexec\s*\(',\n            r'\b__import__\s*\(',\n            r'\bopen\s*\(.*(w|a)\)',  # Write mode file access\n            r'\bshutil\.rmtree\b',\n            r'\bos\.remove\b',\n        ]\n        \n        for pattern in dangerous_patterns:\n            if re.search(pattern, code):\n                return False, f"Potentially dangerous pattern detected: {pattern}"\n        \n        # Try to parse the code\n        try:\n            ast.parse(code)\n        except SyntaxError as e:\n            return False, f"Syntax error: {e}"\n        \n        return True, "Valid"\n    \n    def create_skill(\n        self,\n        name: str,\n        description: str,\n        parameters: list[dict[str, Any]],\n        implementation: str,\n    ) -> tuple[bool, str]:\n        """\n        Create and save a new skill.\n        \n        Args:\n            name: Name of the skill/tool\n            description: What the skill does\n            parameters: List of parameter definitions\n            implementation: The Python code implementing the skill\n            \n        Returns:\n            Tuple of (success, message)\n        """\n        skill_name = self._sanitize_name(name)\n        function_name = f"execute_{skill_name}"\n        tool_name = skill_name.replace('_', '-')\n        \n        # Build parameters signature and docs\n        params_signature_parts = []\n        args_docs_parts = []\n        parameters_list_parts = []\n        \n        for param in parameters:\n            param_name = self._sanitize_name(param.get('name', 'param'))\n            param_type = param.get('type', 'string')\n            param_desc = param.get('description', '')\n            required = param.get('required', True)\n            default = param.get('default')\n            \n            # Python type mapping\n            type_map = {\n                'string': 'str',\n                'integer': 'int',\n                'boolean': 'bool',\n                'number': 'float',\n                'array': 'list',\n                'object': 'dict',\n            }\n            py_type = type_map.get(param_type, 'Any')\n            \n            # Signature\n            if required:\n                params_signature_parts.append(f"{param_name}: {py_type}")\n            else:\n                default_val = repr(default) if default is not None else 'None'\n                params_signature_parts.append(f"{param_name}: {py_type} = {default_val}")\n            \n            # Docs\n            args_docs_parts.append(f"        {param_name}: {param_desc}")\n            \n            # Tool parameter\n            param_def = f'''            ToolParameter(\n                name="{param_name}",\n                param_type="{param_type}",\n                description="{param_desc}",\n                required={required},\n            ),'''\n            parameters_list_parts.append(param_def)\n        \n        parameters_signature = ", ".join(params_signature_parts)\n        args_docs = "\n".join(args_docs_parts) if args_docs_parts else "        None"\n        parameters_list = "\n".join(parameters_list_parts)\n        \n        # Indent implementation properly\n        impl_lines = implementation.strip().split('\n')\n        indented_impl = '\n'.join('        ' + line for line in impl_lines)\n        \n        # Generate the skill file\n        skill_code = SKILL_TEMPLATE.format(\n            skill_name=skill_name,\n            function_name=function_name,\n            tool_name=tool_name,\n            description=description,\n            created_at=datetime.now().isoformat(),\n            parameters_signature=parameters_signature,\n            args_docs=args_docs,\n            implementation=indented_impl,\n            parameters_list=parameters_list,\n        )\n        \n        # Validate the generated code\n        is_valid, message = self._validate_code(skill_code)\n        if not is_valid:\n            return False, f"Generated code is invalid: {message}"\n        \n        # Save the skill\n        skill_file = self.skills_dir / f"{skill_name}.py"\n        skill_file.write_text(skill_code)\n        \n        logger.info("Skill created", name=skill_name, file=str(skill_file))\n        \n        return True, f"Skill '{name}' created successfully at {skill_file}"\n    \n    def load_skill(self, skill_name: str) -> Tool | None:\n        """Load a skill from file."""\n        sanitized = self._sanitize_name(skill_name)\n        skill_file = self.skills_dir / f"{sanitized}.py"\n        \n        if not skill_file.exists():\n            return None\n        \n        try:\n            spec = importlib.util.spec_from_file_location(sanitized, skill_file)\n            module = importlib.util.module_from_spec(spec)\n            spec.loader.exec_module(module)\n            \n            # Look for TOOLS list\n            if hasattr(module, 'TOOLS'):\n                for tool_factory in module.TOOLS:\n                    tool = tool_factory()\n                    self._loaded_skills[tool.name] = tool\n                    return tool\n            \n            return None\n            \n        except Exception as e:\n            logger.error("Failed to load skill", skill=skill_name, error=str(e))\n            return None\n    \n    def load_all_skills(self) -> list[Tool]:\n        """Load all skills from the skills directory."""\n        tools = []\n        \n        for skill_file in self.skills_dir.glob("*.py"):\n            if skill_file.name.startswith("_"):\n                continue\n            \n            skill_name = skill_file.stem\n            tool = self.load_skill(skill_name)\n            if tool:\n                tools.append(tool)\n        \n        return tools\n    \n    def list_skills(self) -> list[dict[str, Any]]:\n        """List all available custom skills."""\n        skills = []\n        \n        for skill_file in self.skills_dir.glob("*.py"):\n            if skill_file.name.startswith("_"):\n                continue\n            \n            # Extract description from file\n            content = skill_file.read_text()\n            desc_match = re.search(r'description="""(.+?)"""', content, re.DOTALL)\n            description = desc_match.group(1).strip() if desc_match else "No description"\n            \n            skills.append({\n                "name": skill_file.stem,\n                "file": str(skill_file),\n                "description": description[:200],  # Truncate\n            })\n        \n        return skills\n    \n    def delete_skill(self, skill_name: str) -> tuple[bool, str]:\n        """Delete a custom skill."""\n        sanitized = self._sanitize_name(skill_name)\n        skill_file = self.skills_dir / f"{sanitized}.py"\n        \n        if not skill_file.exists():\n            return False, f"Skill '{skill_name}' not found"\n        \n        skill_file.unlink()\n        \n        # Remove from loaded skills\n        tool_name = sanitized.replace('_', '-')\n        if tool_name in self._loaded_skills:\n            del self._loaded_skills[tool_name]\n        \n        return True, f"Skill '{skill_name}' deleted"\n    \n    def get_skill_code(self, skill_name: str) -> str | None:\n        """Get the source code of a skill."""\n        sanitized = self._sanitize_name(skill_name)\n        skill_file = self.skills_dir / f"{sanitized}.py"\n        \n        if skill_file.exists():\n            return skill_file.read_text()\n        return None\n\n\ndef create_skill_writer_tools(skills_dir: str | Path | None = None) -> list[Tool]:\n    """Create tools for writing and managing custom skills."""\n    manager = SkillManager(skills_dir)\n    \n    async def write_skill(\n        name: str,\n        description: str,\n        parameters: str,  # JSON string\n        implementation: str,\n    ) -> ToolResult:\n        """Create a new custom skill/tool."""\n        import json\n        \n        try:\n            params = json.loads(parameters) if parameters else []\n            success, message = manager.create_skill(\n                name=name,\n                description=description,\n                parameters=params,\n                implementation=implementation,\n            )\n            return ToolResult(success=success, output=message)\n        except json.JSONDecodeError as e:\n            return ToolResult(success=False, error=f"Invalid parameters JSON: {e}")\n        except Exception as e:\n            return ToolResult(success=False, error=str(e))\n    \n    async def list_skills() -> ToolResult:\n        """List all custom skills."""\n        try:\n            skills = manager.list_skills()\n            if not skills:\n                return ToolResult(success=True, output="No custom skills found.")\n            \n            output = "**Custom Skills:**\n\n"\n            for skill in skills:\n                output += f"\u2022 **{skill['name']}**\n"\n                output += f"  {skill['description']}\n\n"\n            \n            return ToolResult(success=True, output=output)\n        except Exception as e:\n            return ToolResult(success=False, error=str(e))\n    \n    async def view_skill(name: str) -> ToolResult:\n        """View the source code of a custom skill."""\n        try:\n            code = manager.get_skill_code(name)\n            if code:\n                return ToolResult(success=True, output=f"```python\n{code}\n```")\n            return ToolResult(success=False, error=f"Skill '{name}' not found")\n        except Exception as e:\n            return ToolResult(success=False, error=str(e))\n    \n    async def delete_skill(name: str) -> ToolResult:\n        """Delete a custom skill."""\n        try:\n            success, message = manager.delete_skill(name)\n            return ToolResult(success=success, output=message if success else "", error=message if not success else None)\n        except Exception as e:\n            return ToolResult(success=False, error=str(e))\n    \n    async def reload_skills() -> ToolResult:\n        """Reload all custom skills into the tool registry."""\n        try:\n            from . import get_tool_registry\n            registry = get_tool_registry()\n            \n            tools = manager.load_all_skills()\n            for tool in tools:\n                registry.register(tool)\n            \n            return ToolResult(\n                success=True,\n                output=f"Loaded {len(tools)} custom skills: {', '.join(t.name for t in tools)}"\n            )\n        except Exception as e:\n            return ToolResult(success=False, error=str(e))\n    \n    tools = [\n        Tool(\n            name="write_skill",\n            description="""Create a new custom skill/tool that you can use in the future.\n\nUse this to extend your capabilities by writing new tools. The skill will be saved\nand can be loaded in future sessions.\n\nExample parameters JSON:\n[\n    {"name": "query", "type": "string", "description": "Search query", "required": true},\n    {"name": "limit", "type": "integer", "description": "Max results", "required": false, "default": 10}\n]\n\nThe implementation should set a 'result' variable with the output string.""",\n            parameters=[\n                ToolParameter(\n                    name="name",\n                    param_type="string",\n                    description="Name for the new skill (will be converted to valid identifier)",\n                    required=True,\n                ),\n                ToolParameter(\n                    name="description",\n                    param_type="string",\n                    description="What the skill does - this is shown when listing tools",\n                    required=True,\n                ),\n                ToolParameter(\n                    name="parameters",\n                    param_type="string",\n                    description="JSON array of parameter definitions with name, type, description, required, default",\n                    required=True,\n                ),\n                ToolParameter(\n                    name="implementation",\n                    param_type="string",\n                    description="Python code implementing the skill. Must set 'result' variable. Has access to all parameters by name.",\n                    required=True,\n                ),\n            ],\n            handler=write_skill,\n        ),\n        Tool(\n            name="list_skills",\n            description="List all custom skills you've created.",\n            parameters=[],\n            handler=list_skills,\n        ),\n        Tool(\n            name="view_skill",\n            description="View the source code of a custom skill.",\n            parameters=[\n                ToolParameter(\n                    name="name",\n                    param_type="string",\n                    description="Name of the skill to view",\n                    required=True,\n                ),\n            ],\n            handler=view_skill,\n        ),\n        Tool(\n            name="delete_skill",\n            description="Delete a custom skill.",\n            parameters=[\n                ToolParameter(\n                    name="name",\n                    param_type="string",\n                    description="Name of the skill to delete",\n                    required=True,\n                ),\n            ],\n            handler=delete_skill,\n        ),\n        Tool(\n            name="reload_skills",\n            description="Reload all custom skills into the active tool registry.",\n            parameters=[],\n            handler=reload_skills,\n        ),\n    ]\n    \n    return tools\n\n\n# Global skill manager instance\n_skill_manager: SkillManager | None = None\n\ndef get_skill_manager(skills_dir: str | Path | None = None) -> SkillManager:\n    """Get or create the global skill manager."""\n    global _skill_manager\n    if _skill_manager is None:\n        _skill_manager = SkillManager(skills_dir)\n    return _skill_manager\n